# Порівняння жадібного алгоритму та алгоритму динамічного програмування для видачі решти

## Жадібний алгоритм

Жадібний алгоритм вибирає найбільший доступний номінал монет, що не перевищує залишок суми, і повторює цей процес, поки вся сума не буде видана.

### Переваги
- Простий і швидкий у реалізації.
- Підходить для наборів монет, де жадібний підхід гарантує оптимальний результат.

### Недоліки
- Не завжди дає оптимальний результат для всіх можливих наборів монет.

## Алгоритм динамічного програмування

Алгоритм динамічного програмування використовує таблицю для зберігання мінімальної кількості монет для кожної можливої суми від 0 до заданої суми. Він будує рішення, використовуючи попередні розрахунки.

### Переваги
- Гарантує мінімальну кількість монет для будь-якого набору номіналів монет.
- Підходить для будь-яких наборів монет.

### Недоліки
- Може бути повільним для великих сум через складність \(O(n \cdot m)\).
- Вимагає більше пам'яті для зберігання таблиці динамічного програмування.

## Висновки

Жадібний алгоритм є швидшим і простішим у реалізації, але не завжди гарантує мінімальну кількість монет. Алгоритм динамічного програмування забезпечує оптимальний результат, але може бути повільнішим і вимагати більше пам'яті. Вибір алгоритму залежить від конкретних умов задачі: для великих сум та довільних наборів монет краще використовувати алгоритм динамічного програмування, тоді як для стандартних наборів монет жадібний алгоритм може бути достатньо ефективним.

## Приклади використання

### Жадібний алгоритм
```python
def find_coins_greedy(amount):
    coins = [50, 25, 10, 5, 2, 1]
    result = {}
    
    for coin in coins:
        if amount >= coin:
            count = amount // coin
            amount -= coin * count
            result[coin] = count
    
    return result

# Приклад використання:
amount = 113
greedy_result = find_coins_greedy(amount)
print("Жадібний алгоритм:", greedy_result)
